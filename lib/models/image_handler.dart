import 'dart:typed_data';
import 'dart:ui';

import 'package:camera/camera.dart' as pkg_camera;
import 'package:facial_recognition/interfaces.dart';
import 'package:flutter/foundation.dart';
import 'package:image/image.dart' as pkg_image;

class ImageHandler
    implements IImageHandler<pkg_camera.CameraImage, pkg_camera.CameraDescription, pkg_image.Image, Uint8List> {
  ImageHandler();

  /// return a manipulable image from the camera image
  @override
  pkg_image.Image fromCameraImage(
    final pkg_camera.CameraImage image,
    final pkg_camera.CameraDescription description,
  ) {
    final int rollDegrees = description.sensorOrientation;
    final rgbBuffer = _yCbCr420ToRgbBuffer(
      width: image.width,
      height: image.height,
      planes: image.planes,
    );
    final newImage = _toLogicalImage(
      width: image.width,
      height: image.height,
      rgbBytes: rgbBuffer,
      rollDegreeRotation: rollDegrees,
    );
    return newImage;
  }

  /// Convert YCbCr (called YUV) 4:2:0 3-plane to an RGB 1-plane.
  ///
  /// RGB plane is generated by reading the image from left to right and top to
  /// bottom and interleaving the color bytes as r1,g1,b1,r2,g2,b2,....
  ByteBuffer _yCbCr420ToRgbBuffer({
    required final int width,
    required final int height,
    required final List<pkg_camera.Plane> planes,
  }) {
    final yBytes  = planes[0].bytes; // Y
    final cbBytes = planes[1].bytes; // U
    final crBytes = planes[2].bytes; // V
    final yBytesPerPixel = planes[0].bytesPerPixel ?? 1;
    final yBytesPerRow   = planes[0].bytesPerRow;
    final cbCrBytesPerPixel = planes[1].bytesPerPixel ?? 1;
    final cbCrBytesPerRow   = planes[1].bytesPerRow;

    final WriteBuffer rgbBytes = WriteBuffer(startCapacity: 3 * width * height);

    for (int y = 0; y < height; y++) {
      for (int x = 0; x < width; x++) {
        final int yIndex =
            _biToUniDimCoord(x, y, 1, 1, yBytesPerPixel, yBytesPerRow);
        final int cbCrIndex =
            _biToUniDimCoord(x, y, 2, 2, cbCrBytesPerPixel, cbCrBytesPerRow);

        final yV = yBytes[yIndex];
        final cbV = cbBytes[cbCrIndex];
        final crV = crBytes[cbCrIndex];

// identifying which standard to use when converting the YCbCr color to RGB
/*
// unknown - work, found on internet but no rationale
        final r = (yV + crV * 1436 / 1024 - 179)
          .round()
          .clamp(0, 255);
        final g = (yV - cbV * 46549 / 131072 + 44 - crV * 93604 / 131072 + 91)
            .round()
            .clamp(0, 255);
        final b = (yV + cbV * 1814 / 1024 - 227)
          .round()
          .clamp(0, 255);
*/
// JFIF modified Rec.601 with Y,Cb and Cr with full 8-bit range - working
        final cbAux = cbV-128;
        final crAux = crV-128;
        final r = (yV +1.402*(crAux))
          .round()
          .clamp(0, 255);
        final g = (yV -0.344136*(cbAux) -0.714136*(crAux))
          .round()
          .clamp(0, 255);
        final b = (yV +1.772*(cbAux))
          .round()
          .clamp(0, 255);
/**/
/*
// ITU-R BT.601 - working
        final int r = ( (255/219)*(yV-16) +(255/224)*1.402*(crV-128) )
          .round()
          .clamp(0, 255);
        final int g = ( (255/219)*(yV-16) -(255/224)*1.772*(0.114/0.587)*(cbV-128) -(255/224)*1.402*(0.299/0.587)*(crV-128) )
          .round()
          .clamp(0, 255);
        final int b = ( (255/219)*(yV-16) +(255/224)*1.772*(cbV-128) )
          .round()
          .clamp(0, 255);
*/
/*
// ITU-R BT.709 - don't work
        final r = (yV + 1.5748*crV)
          .round()
          .clamp(0, 255);
        final g = (yV - 0.1873*cbV -0.4681*crV)
            .round()
            .clamp(0, 255);
        final b = (yV + 1.8556*cbV)
          .round()
          .clamp(0, 255);
*/
/*
// ITU-R BT.2020 - don't work
        final r = (yV + 1.4746*crV)
          .round()
          .clamp(0, 255);
        final g = (yV - 0.16455312684366*cbV -0.57135312684366*crV)
            .round()
            .clamp(0, 255);
        final b = (yV + 1.8814*cbV)
          .round()
          .clamp(0, 255);
*/
        rgbBytes.putUint8(r);
        rgbBytes.putUint8(g);
        rgbBytes.putUint8(b);
      }
    }

    return rgbBytes.done().buffer;
  }

  /// Find the coord for the element that hold information about the element at coord ([x], [y]).
  ///
  /// 1 element on unidimensional space represent a group of [xGroup] by [yGroup].
  ///
  /// [elementSize] and [xSize] serve to virtualy split the unidimensinal
  /// dimension.
  int _biToUniDimCoord(int x, int y, int xGroup, int yGroup, int elementSize, int xSize) {
    return x ~/ xGroup * elementSize + y ~/ yGroup * xSize;
  }

  pkg_image.Image _toLogicalImage({
    required final int width,
    required final int height,
    required final ByteBuffer rgbBytes,
    required final int rollDegreeRotation,
  }) {
    final image = pkg_image.Image.fromBytes(
      width: width,
      height: height,
      bytes: rgbBytes,
      order: pkg_image.ChannelOrder.rgb,
    );

    final rotatedImage = pkg_image.copyRotate(
      image,
      angle: rollDegreeRotation,
    );
    return rotatedImage;
  }

  /// Return new images from subareas of [image].
  @override
  List<pkg_image.Image> cropFromImage(
    final pkg_image.Image image,
    final List<Rect> rect,
  ) {
    // image origin is (x,y)=(0,0) on the top left corner, x and y grow to the
    // right and bottom respectivelly.
    return rect
        .map((r) => pkg_image.copyCrop(
              image,
              x: (image.width - 1) - (r.right).toInt(),
              y: r.top.toInt(),
              width: r.width.toInt(),
              height: r.height.toInt(),
            ))
        .toList(growable: false);
  }

  /// Resize the *image* to match [size]
  @override
  pkg_image.Image resizeImage(pkg_image.Image image, int width, int height) {
    return pkg_image.copyResize(image, width: width, height: height);
  }

  @override
  pkg_image.Image flipHorizontal(pkg_image.Image image) {
    return pkg_image.flipHorizontal(image);
  }

  ///
  @override
  Uint8List toJpg(pkg_image.Image image) {
    return pkg_image.encodeJpg(image);
  }

  @override
  pkg_image.Image? fromJpg(Uint8List jpgBytes) {
    return pkg_image.decodeJpg(jpgBytes);
  }

  @override
  List<List<List<int>>> toRgbMatrix(pkg_image.Image image) {
    final height = image.height;
    final width = image.width;
    final buffer = image.buffer.asUint8List();
    const nColorChannels = 3;

    // generate lines
    return List.generate(height,
      // generate colums
      (y) => List.generate(width,
        // generate lists of 3 color values
        (x) => List.generate(nColorChannels,
          (z) => buffer[y * width * nColorChannels + x * nColorChannels + z],
          growable: false,
        ),
        growable: false,
      ),
      growable: false,
    );
  }

  @override
  Uint8List toRgbaBuffer(
    pkg_image.Image image,
  ) {
    final buffer = WriteBuffer(startCapacity: image.length*4);
    // pixels are laid from top left to right bottom
    for (final pixel in image) {
      buffer.putUint8(pixel.r.toInt());
      buffer.putUint8(pixel.g.toInt());
      buffer.putUint8(pixel.b.toInt());
      buffer.putUint8(255);
    }
    return buffer.done().buffer.asUint8List();
  }
}

// class toRgbaBufferReturn {
//   toRgbaBufferReturn({
//     required this.buffer,
//     required this.width,
//     required this.height,
//   });

//   final Uint8List buffer;
//   final int width;
//   final int height;
// }