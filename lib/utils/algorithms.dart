import 'dart:typed_data';

import 'package:flutter/services.dart';

enum PlanesFormatsToRgbaPacked {
  yuv420,
  nv21,
  bgra8888,
}

/// convert a camera image to a packed rgba buffer
Uint8List rgbaFromPlanes({
  required final int width,
  required final int height,
  required final PlanesFormatsToRgbaPacked format,
  required final List<
          ({
            int bytesPerPixel,
            int bytesPerRow,
            Uint8List bytes,
          })>
      planes,
}) {
  switch (format) {
    case PlanesFormatsToRgbaPacked.yuv420:
      return _rgbaFromYuv420(
        width: width,
        height: height,
        planes: planes,
      );
    case PlanesFormatsToRgbaPacked.nv21:
      return _rgbaFromNv21(
        width: width,
        height: height,
        planes: planes,
      );
    case PlanesFormatsToRgbaPacked.bgra8888:
      return _rgbaFromBgra8888(
        width: width,
        height: height,
        planes: planes,
      );
  }
}

/// Convert YUV (YCbcr) 4:2:0 3-planar cameraImage to a rgbaBuffer
///
/// RGB plane is generated by reading the image from left to right and top to
/// bottom and interleaving the color bytes as r1,g1,b1,r2,g2,b2,....
Uint8List _rgbaFromYuv420({
  required final int width,
  required final int height,
  required final List<
          ({
            int bytesPerPixel,
            int bytesPerRow,
            Uint8List bytes,
          })>
      planes,
}) {
  if (planes.length != 3) {
    return Uint8List(0);
  }
  final yBytes = planes[0].bytes; // Y
  final cbBytes = planes[1].bytes; // U
  final crBytes = planes[2].bytes; // V
  final yBytesPerPixel = planes[0].bytesPerPixel;
  final yBytesPerRow = planes[0].bytesPerRow;
  final cbCrBytesPerPixel = planes[1].bytesPerPixel;
  final cbCrBytesPerRow = planes[1].bytesPerRow;
  final WriteBuffer rgbaBytes = WriteBuffer(startCapacity: 4 * width * height);

  for (int y = 0; y < height; y++) {
    for (int x = 0; x < width; x++) {
      final int yIndex = map2dTo1dCoordinate(
        x,
        y,
        xLength: yBytesPerRow,
        length: yBytesPerPixel,
      );
      final int cbCrIndex = map2dTo1dCoordinate(
        x,
        y,
        xGroupLength: 2,
        yGroupLength: 2,
        xLength: cbCrBytesPerRow,
        length: cbCrBytesPerPixel,
      );

      final yValue = yBytes[yIndex];
      final uValue = cbBytes[cbCrIndex];
      final vValue = crBytes[cbCrIndex];

      final rgbTuple = _rgbFromYuvRec601FullRange(
        y: yValue,
        u: uValue,
        v: vValue,
      );
      rgbaBytes.putUint8(rgbTuple.r);
      rgbaBytes.putUint8(rgbTuple.g);
      rgbaBytes.putUint8(rgbTuple.b);
      rgbaBytes.putUint8(255);
    }
  }
  return rgbaBytes.done().buffer.asUint8List();
}

Uint8List _rgbaFromNv21({
  required final int width,
  required final int height,
  required final List<
          ({
            int bytesPerPixel,
            int bytesPerRow,
            Uint8List bytes,
          })>
      planes,
}) {
  switch (planes.length) {
    case 1:
      return _rgbaFromNv21OnePlane(width: width, height: height, plane: planes.single,);
    case 2:
      return _rgbaFromNv21TwoPlanes(width: width, height: height, planes: planes,);
    case 3:
      return _rgbaFromNv21ThreePlanes(width: width, height: height, planes: planes,);
    default:
      return Uint8List(0);
  }
}

Uint8List _rgbaFromNv21OnePlane({
  required final int width,
  required final int height,
  required final ({
    int bytesPerPixel,
    int bytesPerRow,
    Uint8List bytes,
  }) plane,
}) {
  final WriteBuffer rgbaBytes = WriteBuffer(startCapacity: 4 * width * height);

  final yBytes = Uint8List.sublistView(
    plane.bytes, 0, width * height,
  );
  final vuBytes = Uint8List.sublistView(
    plane.bytes, width * height, plane.bytes.length,
  );
  final yvuBytesPerPixel = plane.bytesPerPixel;
  final yvuBytesPerRow = plane.bytesPerRow;

  for (int y = 0; y < height; y++) {
    for (int x = 0; x < width; x++) {
      final yIndex = map2dTo1dCoordinate(
        x,
        y,
        xLength: yvuBytesPerRow,
        length: yvuBytesPerPixel,
      );
      final vuIndex = map2dTo1dCoordinate(
        x,
        y,
        xLength: yvuBytesPerRow,
        length: yvuBytesPerPixel * 2,
      );
      final yValue = yBytes[yIndex];
      final vValue = vuBytes[vuIndex];
      final uValue = vuBytes[vuIndex + yvuBytesPerPixel];

      final rgbTuple = _rgbFromYuvRec601FullRange(
        y: yValue,
        u: uValue,
        v: vValue,
      );
      rgbaBytes.putUint8(rgbTuple.r);
      rgbaBytes.putUint8(rgbTuple.g);
      rgbaBytes.putUint8(rgbTuple.b);
      rgbaBytes.putUint8(255);
    }
  }

  return rgbaBytes.done().buffer.asUint8List();
}

Uint8List _rgbaFromNv21TwoPlanes({
  required final int width,
  required final int height,
  required final List<({
    int bytesPerPixel,
    int bytesPerRow,
    Uint8List bytes,
  })> planes,
}) {
  final WriteBuffer rgbaBytes = WriteBuffer(startCapacity: 4 * width * height);

  final yBytes = planes[0].bytes;
  final vuBytes = planes[1].bytes;
  final yBytesPerPixel = planes[0].bytesPerPixel;
  final vuBytesPerPixel = planes[1].bytesPerPixel;
  final vuHalfBytesPerPixel = planes[1].bytesPerPixel ~/ 2;
  final yBytesPerRow = planes[0].bytesPerRow;
  final vuBytesPerRow = planes[1].bytesPerRow;

  for (int y = 0; y < height; y++) {
    for (int x = 0; x < width; x++) {
      final yIndex = map2dTo1dCoordinate(
        x,
        y,
        xLength: yBytesPerRow,
        length: yBytesPerPixel,
      );
      final vuIndex = map2dTo1dCoordinate(
        x,
        y,
        xGroupLength: 2,
        yGroupLength: 2,
        xLength: vuBytesPerRow,
        length: vuBytesPerPixel,
      );
      final yValue = yBytes[yIndex];
      final vValue = vuBytes[vuIndex];
      final uValue = vuBytes[vuIndex + vuHalfBytesPerPixel];

      final rgbTuple = _rgbFromYuvRec601FullRange(
        y: yValue,
        u: uValue,
        v: vValue,
      );
      rgbaBytes.putUint8(rgbTuple.r);
      rgbaBytes.putUint8(rgbTuple.g);
      rgbaBytes.putUint8(rgbTuple.b);
      rgbaBytes.putUint8(255);
    }
  }

  return rgbaBytes.done().buffer.asUint8List();
}

Uint8List _rgbaFromNv21ThreePlanes({
  required final int width,
  required final int height,
  required final List<({
    int bytesPerPixel,
    int bytesPerRow,
    Uint8List bytes,
  })> planes,
}) {
  final WriteBuffer rgbaBytes = WriteBuffer(startCapacity: 4 * width * height);

  final yBytes = planes[0].bytes;
  final vBytes = planes[1].bytes;
  final uBytes = planes[2].bytes;
  final yBytesPerPixel = planes[0].bytesPerPixel;
  final vBytesPerPixel = planes[1].bytesPerPixel;
  final uBytesPerPixel = planes[2].bytesPerPixel;
  final yBytesPerRow = planes[0].bytesPerRow;
  final vBytesPerRow = planes[1].bytesPerRow;
  final uBytesPerRow = planes[2].bytesPerRow;

  for (int y = 0; y < height; y++) {
    for (int x = 0; x < width; x++) {
      final yIndex = map2dTo1dCoordinate(
        x,
        y,
        xLength: yBytesPerRow,
        length: yBytesPerPixel,
      );
      final vIndex = map2dTo1dCoordinate(
        x,
        y,
        xGroupLength: 2,
        yGroupLength: 2,
        xLength: vBytesPerRow,
        length: vBytesPerPixel,
      );
      final uIndex = map2dTo1dCoordinate(
        x,
        y,
        xGroupLength: 2,
        yGroupLength: 2,
        xLength: uBytesPerRow,
        length: uBytesPerPixel,
      );

      final yValue = yBytes[yIndex];
      final vValue = vBytes[vIndex];
      final uValue = uBytes[uIndex];

      final rgbTuple = _rgbFromYuvRec601FullRange(
        y: yValue,
        u: uValue,
        v: vValue,
      );
      rgbaBytes.putUint8(rgbTuple.r);
      rgbaBytes.putUint8(rgbTuple.g);
      rgbaBytes.putUint8(rgbTuple.b);
      rgbaBytes.putUint8(255);
    }
  }

  return rgbaBytes.done().buffer.asUint8List();
}


Uint8List _rgbaFromBgra8888({
  required final int width,
  required final int height,
  required final List<
          ({
            int bytesPerPixel,
            int bytesPerRow,
            Uint8List bytes,
          })>
      planes,
}) {
  if (planes.length != 1) {
    return Uint8List(0);
  }
  final plane = planes.single.bytes;
  final Uint8List rgbaBytes = Uint8List(plane.length);

  for (int i = 0; i < plane.length; i += 4) {
    // 1st: r
    rgbaBytes[i] = plane[i + 2];
    // 2nd: g
    rgbaBytes[i] = plane[i + 1];
    // 3rd: b
    rgbaBytes[i] = plane[i];
    // 4th: a
    rgbaBytes[i] = plane[i + 3];
  }

  return rgbaBytes;
}

({int r, int g, int b}) _rgbFromYuvRec601FullRange({
  required final int y,
  required final int u,
  required final int v,
}) {
  // JFIF modified Rec.601 with Y,Cb and Cr with full 8-bit range - working
  final cbAux = u - 128;
  final crAux = v - 128;
  final r = (y + 1.402 * (crAux)).round().clamp(0, 255);
  final g = (y - 0.344136 * (cbAux) - 0.714136 * (crAux)).round().clamp(0, 255);
  final b = (y + 1.772 * (cbAux)).round().clamp(0, 255);
  return (r: r, g: g, b: b);
}
/*------------------------------------------------------------------------------
other stardards tried to convert yuv to rgb:

// unknown - found on internet, no rationale, but work
        final r = (y + v * 1436 / 1024 - 179)
          .round()
          .clamp(0, 255);
        final g = (y - u * 46549 / 131072 + 44 - v * 93604 / 131072 + 91)
            .round()
            .clamp(0, 255);
        final b = (y + u * 1814 / 1024 - 227)
          .round()
          .clamp(0, 255);

// ITU-R BT.601 - working
        final int r = ( (255/219)*(y-16) +(255/224)*1.402*(v-128) )
          .round()
          .clamp(0, 255);
        final int g = ( (255/219)*(y-16) -(255/224)*1.772*(0.114/0.587)*(u-128) -(255/224)*1.402*(0.299/0.587)*(v-128) )
          .round()
          .clamp(0, 255);
        final int b = ( (255/219)*(y-16) +(255/224)*1.772*(u-128) )
          .round()
          .clamp(0, 255);

// ITU-R BT.709 - don't work
        final r = (y + 1.5748*v)
          .round()
          .clamp(0, 255);
        final g = (y - 0.1873*u -0.4681*v)
            .round()
            .clamp(0, 255);
        final b = (y + 1.8556*u)
          .round()
          .clamp(0, 255);

// ITU-R BT.2020 - don't work
        final r = (y + 1.4746*v)
          .round()
          .clamp(0, 255);
        final g = (y - 0.16455312684366*u -0.57135312684366*v)
            .round()
            .clamp(0, 255);
        final b = (y + 1.8814*u)
          .round()
          .clamp(0, 255);
------------------------------------------------------------------------------*/


// ignore: slash_for_doc_comments
/**
Map 2D coordinates to 1D coordinates.

Narrows 2D coordinates inside an area with size [xGroupLength] by [yGroupLength]
as the same 1D coordinate inside a group of size [length]

for a 2D matrix with width=6, height=4 and with an input of xGroupLength=2,
yGroupLength=2, xLength=8, length=2 this problem instance can be seem as:
```text
       0 1 2 3 4 5
       | | | | | |
  0 - A A B B C C
  1 - A A B B C C  -->  0 1 2 3 4 5 6 7 8 9 101112131415
  2 - D D E E F F  -->  A * B * C * * * D * E * F * * *
  3 - D D E E F F
```

where:
```text
  A A
  A A
```
is [xGroupLength] by [yGroupLength] in size

```text
  A *
```
is [length] in size

```text
  A * B * C * * *
```
is [xLength] in size and dictate the 1D index for the first 2D group on the
second line of groups

result in:
```text
  {(0,0), (0,1), (1,0), (1,1)} -> 0
  {(0,4), (0,5), (1,4), (1,5)} -> 4
  {(2,0), (2,1), (3,0), (3,1)} -> 8
```
*/
int map2dTo1dCoordinate(
  final int x,
  final int y, {
  final int xGroupLength = 1,
  final int yGroupLength = 1,
  required final int xLength,
  final int length = 1,
}) {
  return x ~/ xGroupLength * length + y ~/ yGroupLength * xLength;
}

bool areIterablesEquivalents<T>(
  Iterable<T> iterable1,
  Iterable<T> iterable2,
) {
  if (iterable1.length != iterable2.length) {
    return false;
  } else if (iterable1.isEmpty) {
    return true;
  } else {
    final iterator1 = iterable1.iterator;
    final iterator2 = iterable2.iterator;
    bool haveElement = false;
    haveElement = iterator1.moveNext();
    haveElement &= iterator2.moveNext();
    while (haveElement) {
      int numIterables = 0;
      numIterables += iterator1.current is Iterable ? 1 : 0;
      numIterables += iterator2.current is Iterable ? 1 : 0;

      bool bothEquivalents = false;
      if (numIterables == 2) {
        bothEquivalents = areIterablesEquivalents(
          iterator1.current as Iterable,
          iterator2.current as Iterable,
        );
      }

      if (
        (numIterables == 0 && iterator1.current != iterator2.current) ||
        (numIterables == 1) ||
        (numIterables == 2 && !bothEquivalents)
      ) {
        return false;
      }

      haveElement = iterator1.moveNext();
      haveElement &= iterator2.moveNext();
    }
    return true;
  }
}

Uint8List listDoubleToBytes(List<double> list) {
  const bytesSize = 8;
  final buffer = ByteData(bytesSize * list.length);
  for (int i = 0; i < list.length; i++) {
    buffer.setFloat64(i * bytesSize, list[i], Endian.big);
  }
  final bufferBytes = buffer.buffer.asUint8List();
  return bufferBytes;
}

List<double> listBytesToDouble(Uint8List list) {
  const sizeBytes = 8;
  final buffer = List.filled(list.length ~/ sizeBytes, 0.0);
  final byteData = list.buffer.asByteData();
  for (int i = 0; i < buffer.length; i++) {
    final value = byteData.getFloat64(sizeBytes * i, Endian.big);
    buffer[i] = value;
  }
  return buffer;
}

void main(List<String> args) {
  final i1 = [[],1,2,3];
  final i2 = [0,1,2,3];

  areIterablesEquivalents(i1, i2);
}
